From: David Edmundson <kde@davidedmundson.co.uk>
Date: Fri, 27 Jan 2017 09:11:17 +0000
Subject: Work round DBus property fetching bug

Summary:
property() works in a slightly different way to just calling Get().
It allocates the variant of the relevant type in advance in QObject
code, and then calls
the DBus code to populate it.

This fails for QByteArrayList, before it reaches DBus code.
I don't know why, but we need a wokraround in Solid anyway.

>From a DBus traffic perspective this code is identical, we just avoid
going through Qt properties.

This shouldn't introduce any new bugs, as we already use GetAll
directly, if anything this brings it more
in line.

BUG: 345871

Test Plan:
Commented out the checkCache so that it always loads data.
Instead of failing, it now works.

Subscribers: #frameworks

Tags: #frameworks

Differential Revision: https://phabricator.kde.org/D4305
---
 .../backends/udisks2/udisksdevicebackend.cpp       | 22 +++++++++++++---------
 1 file changed, 13 insertions(+), 9 deletions(-)

diff --git a/src/solid/devices/backends/udisks2/udisksdevicebackend.cpp b/src/solid/devices/backends/udisks2/udisksdevicebackend.cpp
index c49001f..eaaa307 100644
--- a/src/solid/devices/backends/udisks2/udisksdevicebackend.cpp
+++ b/src/solid/devices/backends/udisks2/udisksdevicebackend.cpp
@@ -182,15 +182,19 @@ void DeviceBackend::checkCache(const QString &key) const
         return;
     }
 
-    QVariant reply = m_device->property(key.toUtf8());
-    m_propertyCache.insert(key, reply);
-
-    if (!reply.isValid()) {
-        /* Store the item in the cache anyway so next time we don't have to
-         * do the DBus call to find out it does not exist but just check whether
-         * prop(key).isValid() */
-//         qDebug() << m_udi << ": property" << key << "does not exist";
-    }
+    QDBusMessage call = QDBusMessage::createMethodCall(UD2_DBUS_SERVICE, m_udi, DBUS_INTERFACE_PROPS, "Get");
+    /*
+     * Interface is set to an empty string as in this QDBusInterface is a meta-object of multiple interfaces on the same path
+     * The DBus properties also interface supports this, and will find the appropriate interface if none is explicitly set.
+     * This matches what QDBusAbstractInterface would do
+     */
+    call.setArguments(QVariantList() << QString() << key);
+    QDBusPendingReply<QVariant> reply = QDBusConnection::systemBus().call(call);
+
+    /* We don't check for error here and store the item in the cache anyway so next time we don't have to
+     * do the DBus call to find out it does not exist but just check whether
+     * prop(key).isValid() */
+    m_propertyCache.insert(key, reply.value());
 }
 
 void DeviceBackend::slotPropertiesChanged(const QString &ifaceName, const QVariantMap &changedProps, const QStringList &invalidatedProps)
